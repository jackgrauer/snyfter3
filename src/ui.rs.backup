// Terminal UI rendering for NValt-like interface

use anyhow::Result;
use crossterm::{
    cursor,
    style::{self, Color, SetBackgroundColor, SetForegroundColor},
    terminal,
    execute,
};
use std::io;
use unicode_width::UnicodeWidthStr;

use crate::{App, FocusArea};
use crate::markdown::MarkdownRenderer;
use crate::syntax::SyntaxHighlighter;
use crate::edit_renderer::EditPanelRenderer;

pub struct UI {
    markdown_renderer: MarkdownRenderer,
    syntax_highlighter: SyntaxHighlighter,
    edit_renderer: EditPanelRenderer,
}

impl UI {
    pub fn new() -> Result<Self> {
        Ok(UI {
            markdown_renderer: MarkdownRenderer::new(),
            syntax_highlighter: SyntaxHighlighter::new()?,
            edit_renderer: EditPanelRenderer::new(80, 24),  // Default size, will be updated
        })
    }

    pub fn render(&mut self, app: &App) -> Result<()> {
        let (width, height) = terminal::size()?;

        // Clear screen
        execute!(
            io::stdout(),
            terminal::Clear(terminal::ClearType::All),
            cursor::MoveTo(0, 0),
        )?;

        // Calculate split positions (left-right split)
        let split_x = (width as f32 * app.split_ratio) as u16;
        let editor_width = width.saturating_sub(split_x + 1);  // +1 for divider

        // Always render header and search bar
        self.render_header(app, width)?;
        self.render_search_bar(app, width)?;

        // Render note list on left (starting at line 3)
        self.render_note_list(app, split_x, 2, height - 3)?;  // -3 for header, search, and status

        // Render divider
        self.render_divider(split_x, 2, height - 3, app.dragging_divider)?;

        // Render editor on right
        self.render_editor(app, split_x + 1, editor_width, 2, height - 3)?;

        self.render_status_bar(app, width, height)?;

        // Position cursor based on focus area
        match app.focus_area {
            FocusArea::SearchBar => {
                let search_len = app.search_query.width() as u16;
                execute!(io::stdout(), cursor::Show, cursor::MoveTo(9 + search_len, 1))?;
            }
            _ => {
                // Hide the terminal cursor - we render our own block cursor in editor
                execute!(io::stdout(), cursor::Hide)?;
            }
        }

        Ok(())
    }

    fn render_header(&self, app: &App, width: u16) -> Result<()> {
        execute!(
            io::stdout(),
            cursor::MoveTo(0, 0),
            SetBackgroundColor(Color::Rgb { r: 40, g: 40, b: 40 }),
            SetForegroundColor(Color::Rgb { r: 200, g: 200, b: 200 }),
        )?;

        let header = format!(" Snyfter3 - {} notes ",
            app.notes.get_note_count()
        );

        print!("{:width$}", header, width = width as usize);

        execute!(
            io::stdout(),
            style::ResetColor,
        )?;

        Ok(())
    }

    fn render_divider(&self, x: u16, start_y: u16, height: u16, is_dragging: bool) -> Result<()> {
        let color = if is_dragging {
            Color::Rgb { r: 100, g: 150, b: 200 }
        } else {
            Color::Rgb { r: 60, g: 60, b: 60 }
        };

        for y in start_y..start_y + height {
            execute!(
                io::stdout(),
                cursor::MoveTo(x, y),
                SetForegroundColor(color),
            )?;
            print!("│");
        }

        execute!(io::stdout(), style::ResetColor)?;
        Ok(())
    }

    fn render_search_bar(&self, app: &App, width: u16) -> Result<()> {
        let is_focused = app.focus_area == FocusArea::SearchBar;

        execute!(
            io::stdout(),
            cursor::MoveTo(0, 1),
            SetBackgroundColor(if is_focused {
                Color::Rgb { r: 50, g: 70, b: 120 }  // Blue background when focused
            } else {
                Color::Rgb { r: 35, g: 35, b: 35 }
            }),
            SetForegroundColor(if is_focused {
                Color::White
            } else {
                Color::Rgb { r: 150, g: 150, b: 150 }
            }),
        )?;

        print!(" Search: {}", app.search_query);

        // Show match count
        let match_info = format!(" ({} notes) ", app.filtered_notes.len());

        // Clear rest of line
        let used = 9 + app.search_query.width() + match_info.width();
        if used < width as usize {
            print!("{}", match_info);
            print!("{:width$}", "", width = width as usize - used);
        }

        execute!(io::stdout(), style::ResetColor)?;
        Ok(())
    }

    fn render_note_list(&self, app: &App, width: u16, start_y: u16, height: u16) -> Result<()> {
        // Display search results if searching, otherwise all notes
        let display_height = height - 1;

        // Render list header with focus indication
        let is_focused = app.focus_area == FocusArea::NoteList;

        execute!(
            io::stdout(),
            cursor::MoveTo(0, start_y),
            SetBackgroundColor(if is_focused {
                Color::Rgb { r: 40, g: 50, b: 70 }  // Darker blue when focused
            } else {
                Color::Rgb { r: 30, g: 30, b: 30 }
            }),
            SetForegroundColor(if is_focused {
                Color::Rgb { r: 200, g: 200, b: 200 }
            } else {
                Color::Rgb { r: 150, g: 150, b: 150 }
            }),
        )?;

        print!("{:width$}", " NOTES", width = width as usize);

        // Render filtered notes
        for (i, note) in app.filtered_notes.iter().enumerate() {
            if i >= display_height as usize {
                break;
            }

            let y = start_y + 1 + i as u16;
            execute!(io::stdout(), cursor::MoveTo(0, y))?;

            // Highlight selected note
            if i == app.selected_note_index {
                execute!(
                    io::stdout(),
                    SetBackgroundColor(Color::Rgb { r: 60, g: 60, b: 100 }),
                    SetForegroundColor(Color::Rgb { r: 255, g: 255, b: 255 }),
                )?;
            } else {
                execute!(
                    io::stdout(),
                    SetBackgroundColor(Color::Black),
                    SetForegroundColor(Color::Rgb { r: 200, g: 200, b: 200 }),
                )?;
            }

            // Format note line
            let title = if note.title.width() > (width as usize - 4) {
                format!("{}...", &note.title.chars().take(width as usize - 7).collect::<String>())
            } else {
                note.title.clone()
            };

            print!(" {:<width$}", title, width = width as usize - 1);
        }

        // Clear remaining lines
        for i in app.filtered_notes.len()..display_height as usize {
            let y = start_y + 1 + i as u16;
            execute!(
                io::stdout(),
                cursor::MoveTo(0, y),
                SetBackgroundColor(Color::Black),
            )?;
            print!("{:width$}", "", width = width as usize);
        }


        execute!(io::stdout(), style::ResetColor)?;
        Ok(())
    }

    fn render_editor(&mut self, app: &App, start_x: u16, width: u16, start_y: u16, height: u16) -> Result<()> {
        // Render editor header with focus indication
        let is_focused = app.focus_area == FocusArea::Editor;

        execute!(
            io::stdout(),
            cursor::MoveTo(start_x, start_y),
            SetBackgroundColor(if is_focused {
                Color::Rgb { r: 40, g: 50, b: 70 }  // Darker blue when focused
            } else {
                Color::Rgb { r: 30, g: 30, b: 30 }
            }),
            SetForegroundColor(if is_focused {
                Color::Rgb { r: 200, g: 200, b: 200 }
            } else {
                Color::Rgb { r: 150, g: 150, b: 150 }
            }),
        )?;

        let editor_header = if let Some(ref note) = app.selected_note {
            format!(" EDITOR - {} ", note.title)
        } else {
            " EDITOR - No note selected ".to_string()
        };

        print!("{:width$}", editor_header, width = width as usize);

        // Render editor content
        execute!(
            io::stdout(),
            SetBackgroundColor(Color::Black),
            SetForegroundColor(Color::Rgb { r: 200, g: 200, b: 200 }),
        )?;

        if let Some(ref _note) = app.selected_note {
            // Get visible lines from editor
            let visible_lines = app.editor.get_visible_lines(height as usize - 1);
            let (cursor_row, cursor_col) = app.editor.get_cursor_screen_position();

            for (i, line) in visible_lines.iter().enumerate() {
                if i >= height as usize - 1 {
                    break;
                }

                let y = start_y + 1 + i as u16;
                execute!(io::stdout(), cursor::MoveTo(start_x, y))?;

                // Apply markdown formatting
                let formatted = self.markdown_renderer.render_line(line);

                // Get selection range for this line if any
                let selection_range = if app.editor.has_selection() {
                    let range = app.editor.selection.primary();
                    let line_start_pos = visible_lines.iter().take(i).map(|l| l.len() + 1).sum::<usize>();
                    let line_end_pos = line_start_pos + line.len();

                    if range.from() < line_end_pos && range.to() > line_start_pos {
                        Some((
                            range.from().saturating_sub(line_start_pos),
                            range.to().min(line_end_pos).saturating_sub(line_start_pos)
                        ))
                    } else {
                        None
                    }
                } else {
                    None
                };

                if app.selected_note.is_some() && app.focus_area == FocusArea::Editor && i == cursor_row {
                    // Render line with cursor and formatting
                    print!(" ");

                    // Render each character with proper highlighting
                    for (col_idx, ch) in line.chars().enumerate() {
                        let mut bg_color = Color::Black;
                        let mut fg_color = Color::Rgb { r: 200, g: 200, b: 200 };

                        // Check if this character is selected
                        if let Some((sel_start, sel_end)) = selection_range {
                            if col_idx >= sel_start && col_idx < sel_end {
                                bg_color = Color::Rgb { r: 40, g: 60, b: 100 };
                                fg_color = Color::Rgb { r: 255, g: 255, b: 255 };
                            }
                        }

                        // Apply markdown formatting colors if applicable
                        for segment in &formatted.segments {
                            if col_idx >= segment.start && col_idx < segment.end {
                                if bg_color == Color::Black {  // Only apply if not selected
                                    fg_color = segment.style.color;
                                    if segment.style.bold {
                                        if let Color::Rgb { r, g, b } = fg_color {
                                            fg_color = Color::Rgb {
                                                r: (r + 30).min(255),
                                                g: (g + 30).min(255),
                                                b: (b + 30).min(255),
                                            };
                                        }
                                    }
                                }
                                break;
                            }
                        }

                        // Render cursor as block
                        if col_idx == cursor_col {
                            execute!(
                                io::stdout(),
                                SetBackgroundColor(Color::Rgb { r: 200, g: 200, b: 200 }),
                                SetForegroundColor(Color::Black),
                            )?;
                            print!("{}", ch);
                            execute!(
                                io::stdout(),
                                SetBackgroundColor(bg_color),
                                SetForegroundColor(fg_color),
                            )?;
                        } else {
                            execute!(
                                io::stdout(),
                                SetBackgroundColor(bg_color),
                                SetForegroundColor(fg_color),
                            )?;
                            print!("{}", ch);
                        }
                    }
                    // Show cursor in virtual space (past end of line)
                    if cursor_col >= line.len() {
                        // Add spaces up to cursor position
                        let spaces_to_cursor = cursor_col.saturating_sub(line.len());
                        for space_idx in 0..=spaces_to_cursor {
                            if space_idx == spaces_to_cursor {
                                // This is the cursor position
                                execute!(
                                    io::stdout(),
                                    SetBackgroundColor(Color::Rgb { r: 200, g: 200, b: 200 }),
                                    SetForegroundColor(Color::Black),
                                )?;
                                print!(" ");
                                execute!(
                                    io::stdout(),
                                    SetBackgroundColor(Color::Black),
                                    SetForegroundColor(Color::Rgb { r: 200, g: 200, b: 200 }),
                                )?;
                            } else {
                                // Regular space
                                print!(" ");
                            }
                        }
                    }
                    // Fill rest of line
                    let printed = 1 + line.width() + cursor_col.saturating_sub(line.len());
                    if printed < width as usize {
                        print!("{:width$}", "", width = width as usize - printed);
                    }
                } else {
                    // Regular line rendering with markdown formatting
                    print!(" ");
                    let formatted = self.markdown_renderer.render_line(line);

                    if formatted.segments.is_empty() {
                        // No formatting, render plain
                        execute!(io::stdout(), SetForegroundColor(Color::Rgb { r: 200, g: 200, b: 200 }))?;
                        print!("{:<width$}", line, width = width as usize - 1);
                    } else {
                        // Apply markdown formatting
                        let mut last_end = 0;
                        for segment in &formatted.segments {
                            // Print text before this segment
                            if segment.start > last_end {
                                execute!(io::stdout(), SetForegroundColor(Color::Rgb { r: 200, g: 200, b: 200 }))?;
                                print!("{}", &line[last_end..segment.start]);
                            }

                            // Apply segment style
                            let mut fg_color = segment.style.color;
                            if segment.style.bold {
                                if let Color::Rgb { r, g, b } = fg_color {
                                    fg_color = Color::Rgb {
                                        r: (r + 30).min(255),
                                        g: (g + 30).min(255),
                                        b: (b + 30).min(255),
                                    };
                                }
                            }

                            execute!(io::stdout(), SetForegroundColor(fg_color))?;
                            if segment.style.underline {
                                execute!(io::stdout(), style::SetAttribute(style::Attribute::Underlined))?;
                            }

                            let segment_text = &line[segment.start..segment.end.min(line.len())];
                            print!("{}", segment_text);

                            if segment.style.underline {
                                execute!(io::stdout(), style::SetAttribute(style::Attribute::Reset))?;
                            }

                            last_end = segment.end;
                        }

                        // Print remaining text
                        if last_end < line.len() {
                            execute!(io::stdout(), SetForegroundColor(Color::Rgb { r: 200, g: 200, b: 200 }))?;
                            print!("{}", &line[last_end..]);
                        }

                        // Fill rest of line
                        let printed = 1 + line.width();
                        if printed < width as usize {
                            print!("{:width$}", "", width = width as usize - printed);
                        }
                    }
                }

            }

            // Clear remaining lines
            for i in visible_lines.len()..height as usize - 1 {
                let y = start_y + 1 + i as u16;
                execute!(io::stdout(), cursor::MoveTo(start_x, y))?;
                print!("{:width$}", "", width = width as usize);
            }
        } else {
            // No note selected - show placeholder
            for i in 0..height - 1 {
                let y = start_y + 1 + i;
                execute!(io::stdout(), cursor::MoveTo(start_x, y))?;

                if i == height / 2 - 1 {
                    let msg = "Select or create a note to begin editing";
                    let padding = (width as usize - msg.len()) / 2;
                    print!("{:padding$}{}{:padding$}", "", msg, "",
                           padding = padding);
                } else {
                    print!("{:width$}", "", width = width as usize);
                }
            }
        }

        execute!(io::stdout(), style::ResetColor)?;
        Ok(())
    }

    fn render_status_bar(&self, app: &App, width: u16, height: u16) -> Result<()> {
        execute!(
            io::stdout(),
            cursor::MoveTo(0, height - 1),
            SetBackgroundColor(Color::Rgb { r: 40, g: 40, b: 40 }),
            SetForegroundColor(Color::Rgb { r: 180, g: 180, b: 180 }),
        )?;

        let left_status = format!(" {} ", app.status_message);

        let shortcuts = match app.focus_area {
            FocusArea::SearchBar => "ESC/Enter/↓: Exit Search | Type to filter notes",
            FocusArea::NoteList => "^Q: Quit | ^N: New | ^L/^F: Search | Enter/→: Edit | ^D: Delete | Tab: Switch Focus",
            FocusArea::Editor => "ESC/←: Back to List | ^X: Cut | ^C: Copy | ^V: Paste | ^A: Select All | Tab: Switch Focus",
        };

        let right_status = format!(" {} ", shortcuts);

        print!("{}", left_status);

        let padding = width as usize - left_status.width() - right_status.width();
        if padding > 0 {
            print!("{:width$}", "", width = padding);
        }

        print!("{}", right_status);

        execute!(io::stdout(), style::ResetColor)?;
        Ok(())
    }
}